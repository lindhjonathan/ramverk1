---
---
Redovisning kmom02
=========================

Detta innehåll är skrivet i markdown och du hittar innehållet i filen `content/redovisning/02_kmom02.md`.

Model View Controller
=====================
Den generella tanken med en MVC är inte så främmande. Att sträva efter återanvändbar, hållbar kod är väl något man alltid hoppas uppnå. Just när man tänker strukturmässigt känns det naturligt att ha logisk kod som behandlar data på olika sätt exklusivt i modeller. Ett ställe att ändra/arbeta på, enkelt. Att ha tunna kontrollers som gör anrop till modeller, skickar och tar emot data för att sedan vidarebefordra denna till en vy. Jag hittar en del argument som tyder på att arbete emot en applikation som följer MVC-mönstret tillåter och framför allt förenklar arbete i grupp. MVC i sig är så pass tydligt och lätt uppdelat att funktioner kan arbetas på parallellt på flera håll.
Personligen upplevde jag att anax blev lättare att navigera när man lade till modeller och tunnade ut controllers, mer tydlighet framför allt. I dagsläget ser jag inte nödvändigheten i att tillåta kommunikation direkt mellan modell och vy, dvs att controllern blir en del av vyn, som några sidor påstår man kan göra. Jag uppskattar enkelheten i dataflödet som finns i det system vi har implementerat i kmom02. [Tomdalling](https://www.tomdalling.com/blog/software-design/model-view-controller-explained/) nämner detta sätt att strukturera sin MVC-app.

SOLID och Designmönster
=======================
Helhetstänket bakom SOLID känns också naturligt på något vis. Simpliciteten och klarheten i Single Responsibility och Open/Closed, de gör att mindre kod behöver laddas in, färre metoder och klasser behöver tugga bandbredd bara för att ligga oanvända i bakgrunden. Detsamma gäller I:et, fler interfaces med färre och mer specifika uppgifter lämnar användaren med en ren applikation som bara laddar det den behöver. Jag vände mig till [Medium](https://medium.com/mindorks/solid-principles-explained-with-examples-79d1ce114ace) för att hitta en greppbar förklaring av SOLID, då jag tyckte att videon med Gareth Ellis var lite väl tung på exempel, ibland lite avancerade vilket gjorde det lite svårare att följa. Jag förstår dock att videon var så avancerad den behövde vara för att till fullo förklara vissa delar av SOLID och att detta är faktiska kodexempel som man kan förvänta sig när man kommer lite längre i sin förståelse för programmering generellt, då kommer det också vara lättare att t.ex. identifiera stycken i sin kod som kan refactora till att följa SOLID på ett bättre sätt. Jag kommer försöka att ha SOLID i bakhuvudet när jag skapar framtida verk, men som med allt annat kommer det ta tid och övning innan man kan förstå konceptet till fullo. En detalj jag lyckats plocka ut från videon är, mycket kanske just vid D - Dependency Injection, är att formulering av anrop är mycket viktig, det tillåter modell/controller att vara så nedskalad som möjligt. Detta tycker jag summerar SOLID på ett bra sätt, nedskalat med små klasser som har så få uppgifter som möjligt. Arbeta utefter detta så blir koden lättläslig och funktionell, vilket också gör att det är lätt att extenda våra klasser och jobba mot klara mål med applikationen.

För att spinna vidare på SOLID så kollade jag lite närmre på hur Symfony hanterar sina basklasser och services, huruvida de följde SOLID till en rimlig nivå eller inte. Deras $di container fungerar liknande anax, de tjänster som behövs laddar man in explicit och därmed håller nere kostnaden. Det var utmanande att navigera en manual som man ej är insatt i alls, men intressant att se vissa likheter med sådant man redan känner till. Jag försökte dessutom hålla ett öga öppet för att identifiera användning av designmönster, men begränsad kunskap inom designmönster samt oerfarenheten med symfony gjorde det svårt att komma fram till några konkreta observationer.

När det kommer till just designmönster är det nog ett begrepp jag i förväg bara stött på några gånger, men aldrig dykt ner i förrän nu. MVC är ju ett exempel på kodstruktor som kan ses som ett designmönster, och det är väl det ett designmönster egentligen är; en lösning på ett vanligt förekommande problem som håller god kodstandard och struktur, sådant att den kan vara återanvändbar i flera aspekter av en eller flera applikationer. Några av hemsidorna jag har kollat på argumenterar dock att hela begreppet 'designmönster' är onödigt i sig, detta baseras på tanken att god kodstandard och struktur från början ska vara nog utan att behöva följa ett givet mönster.
Jag kollade lite närmre på några beteende- och struktur-designmönster. Det finns ytterligare ett par olika typer av designmönster, men dessa verkar mest intressanta. Composite-pattern är en av de jag kollade på, den tillhandahåller en struktur för att klumpa ihop lika objekt och behandla de som om de vore ett enda, men fortfarande med möjligheten att behandla som individuella objekt.
Chain of Responsibility är ett beteendemönster som bilder en kedja av objekt, där ett anrop kallas mot första klassen och skickas tillbaks till basklassen sedan vidare till nästa om datan ej kan hanteras av nuvarande klass. Varje klass i kedjan känner till nästa klass, men inte mer än så. Jag kan se användbarheten, men den är också väldigt begränsad till en viss typ av objekt. I fel system är den känner jag att den strider mot SOLID, då en massa klasser anropas och objekt skapas i onödan.
Ett annat strukturmönster som kan vara både användbart och nödvändigt för till exempel enhetstestning är Proxy Pattern. Man skapar en instans av ett originalobjekt och kör t.ex. tester mot proxyn instället för originalobjektet.

Kursmomentet
============
Vilken är din TIL för detta kmom?
Korsmomentet var väldigt likt det föregående. Introduktionen till MVC kändes bra, jag tror det ger en del av en bra grund att stå på inför kommande moment.
TIL en mycket väl applicerbar verson av MVC.
